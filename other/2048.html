<!DOCTYPE html>
<html>
<head>
<title>2048 小游戏</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
  body {
    font-family: Arial, sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background-color: #faf8ef;
    flex-direction: column;
    margin: 0;
  }
  h1, p {
    color: #776e65;
  }
  #game-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 444px;
    margin-bottom: 10px;
  }
  #game-info p {
    font-size: 24px;
    font-weight: bold;
    margin: 0;
  }
  #game-info button {
    background-color: #8f7a66;
    color: #f9f6f2;
    border: none;
    border-radius: 3px;
    padding: 10px 20px;
    font-size: 16px;
    cursor: pointer;
    transition: background-color 0.2s;
  }
  #game-info button:hover {
    background-color: #9f8b75;
  }
  #game-container {
    background-color: #bbada0;
    padding: 12px;
    border-radius: 6px;
    position: relative;
    width: 420px;
    height: 420px;
    box-sizing: content-box;
    overflow: hidden;
    touch-action: none; /* 防止页面滚动 */
  }
  #game-grid {
    display: grid;
    grid-template-columns: repeat(4, 100px);
    grid-template-rows: repeat(4, 100px);
    gap: 10px;
  }
  .grid-cell {
    width: 100px;
    height: 100px;
    background-color: #ccc0b3;
    border-radius: 3px;
  }
  .tile {
    width: 100px;
    height: 100px;
    background-color: #eee4da;
    border-radius: 3px;
    font-size: 55px;
    font-weight: bold;
    display: flex;
    justify-content: center;
    align-items: center;
    color: #776e65;
    position: absolute;
    transition: left 0.1s ease-in-out, top 0.1s ease-in-out, transform 0.1s ease-in-out, opacity 0.1s ease-in-out;
  }
  /* 根据数值设置方块颜色和文字大小 */
  .tile-2 { background-color: #eee4da; color: #776e65; }
  .tile-4 { background-color: #ede0c8; color: #776e65; }
  .tile-8 { background-color: #f2b179; color: #f9f6f2; }
  .tile-16 { background-color: #f59563; color: #f9f6f2; }
  .tile-32 { background-color: #f67c5f; color: #f9f6f2; }
  .tile-64 { background-color: #f65e3b; color: #f9f6f2; }
  .tile-128 { background-color: #edcf72; color: #f9f6f2; font-size: 45px; }
  .tile-256 { background-color: #edcc61; color: #f9f6f2; font-size: 45px; }
  .tile-512 { background-color: #edc850; color: #f9f6f2; font-size: 45px; }
  .tile-1024 { background-color: #edc53f; color: #f9f6f2; font-size: 35px; }
  .tile-2048 { background-color: #edc22e; color: #f9f6f2; font-size: 35px; }
  .tile-4096 { background-color: #3c3a32; color: #f9f6f2; font-size: 30px; }
  .tile-8192 { background-color: #272621; color: #f9f6f2; font-size: 30px; }

  /* 游戏结束的样式 */
  #game-over {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(250, 248, 239, 0.7);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 10;
    border-radius: 6px;
    text-align: center;
  }
  #game-over h2 {
    font-size: 60px;
    color: #776e65;
    margin: 0;
  }
  #game-over p {
    font-size: 24px;
    margin: 10px 0;
  }
  #game-over button {
    background-color: #8f7a66;
    color: #f9f6f2;
    border: none;
    border-radius: 3px;
    padding: 10px 20px;
    font-size: 16px;
    cursor: pointer;
    margin-top: 20px;
  }

  /* 媒体查询：适配手机屏幕 */
  @media (max-width: 500px) {
    body {
      height: auto;
      min-height: 100vh;
      justify-content: flex-start;
      padding: 20px;
    }
    h1 {
      font-size: 2em;
    }
    #game-info {
      width: 100%;
      max-width: 444px;
      margin-bottom: 20px;
      flex-direction: column;
      gap: 10px;
    }
    #game-container {
      width: 100%;
      height: auto;
      padding: 5px;
      max-width: 420px;
    }
    #game-grid {
      grid-template-columns: repeat(4, minmax(0, 1fr));
      grid-template-rows: repeat(4, minmax(0, 1fr));
      gap: 5px;
      width: 100%;
      aspect-ratio: 1 / 1;
    }
    .grid-cell, .tile {
      width: auto;
      height: auto;
      border-radius: 3px;
      min-width: 50px;
      min-height: 50px;
      font-size: 1.5em;
    }
  }
</style>
</head>
<body>

<h1>2048 小游戏</h1>
<div id="game-info">
    <p>分数：<span id="score">0</span></p>
    <button id="restart-btn">重新开始</button>
</div>
<div id="game-container">
  <div id="game-grid">
    <div class="grid-cell"></div>
    <div class="grid-cell"></div>
    <div class="grid-cell"></div>
    <div class="grid-cell"></div>
    <div class="grid-cell"></div>
    <div class="grid-cell"></div>
    <div class="grid-cell"></div>
    <div class="grid-cell"></div>
    <div class="grid-cell"></div>
    <div class="grid-cell"></div>
    <div class="grid-cell"></div>
    <div class="grid-cell"></div>
    <div class="grid-cell"></div>
    <div class="grid-cell"></div>
    <div class="grid-cell"></div>
    <div class="grid-cell"></div>
  </div>
  <div id="game-over" style="display: none;">
      <h2>游戏结束！</h2>
      <p>你获得了 <span id="final-score">0</span> 分！</p>
      <button onclick="setupGame()">再玩一次</button>
  </div>
</div>
<p>使用键盘方向键 (上,下,左,右) 或滑动屏幕来移动方块。</p>

<script>
  let board = [];
  const rows = 4;
  const cols = 4;
  let score = 0;
  let id = 0;
  const container = document.getElementById('game-container');
  const gridContainer = document.getElementById('game-grid');
  let isGameOver = false;
  let isMoving = false;
  let tiles = new Map();

  let startX = 0;
  let startY = 0;

  window.onload = function() {
    setupGame();
  }

  function setupGame() {
    board = Array.from({ length: rows }, () => Array(cols).fill(0));
    score = 0;
    isGameOver = false;
    isMoving = false;
    id = 0;
    tiles.clear();
    document.getElementById('score').innerText = score;
    document.getElementById('game-over').style.display = 'none';
    
    container.querySelectorAll('.tile').forEach(tile => tile.remove());
    
    while (gridContainer.firstChild) {
      gridContainer.removeChild(gridContainer.firstChild);
    }
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        let cell = document.createElement('div');
        cell.classList.add('grid-cell');
        gridContainer.appendChild(cell);
      }
    }
    
    addRandomTile();
    addRandomTile();
  }

  function getPosition(r, c) {
    const gameContainer = document.getElementById('game-container');
    const containerSize = gameContainer.offsetWidth - 24; // 减去padding
    const cellSize = (containerSize - 3 * 10) / 4; // 4个单元格，3个间隙
    const gap = 10;
    const containerPadding = 12;

    const top = containerPadding + r * (cellSize + gap);
    const left = containerPadding + c * (cellSize + gap);
    
    return {
      left: `${left}px`,
      top: `${top}px`
    };
  }

  function createTileElement(value, r, c, tileId) {
    const tile = document.createElement('div');
    tile.classList.add('tile', `tile-${value}`);
    tile.innerText = value;
    const pos = getPosition(r, c);
    tile.style.left = pos.left;
    tile.style.top = pos.top;
    tile.dataset.id = tileId;
    return tile;
  }

  function addRandomTile() {
    let emptyTiles = [];
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        if (board[r][c] === 0) {
          emptyTiles.push({ r, c });
        }
      }
    }
    if (emptyTiles.length > 0) {
      const { r, c } = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
      const value = Math.random() < 0.9 ? 2 : 4;
      board[r][c] = { value, id: id++ };
      
      const newTile = createTileElement(value, r, c, board[r][c].id);
      tiles.set(board[r][c].id, newTile);
      container.appendChild(newTile);
      
      newTile.style.transform = 'scale(0)';
      setTimeout(() => {
        newTile.style.transform = 'scale(1)';
      }, 10);
    }
  }
  
  // 键盘事件
  document.addEventListener('keyup', (e) => {
    if (isGameOver || isMoving) return;
    
    const originalBoard = JSON.parse(JSON.stringify(board));
    let moved = false;

    if (e.key === 'ArrowLeft') { moved = slideLeft(); }
    else if (e.key === 'ArrowRight') { moved = slideRight(); }
    else if (e.key === 'ArrowUp') { moved = slideUp(); }
    else if (e.key === 'ArrowDown') { moved = slideDown(); }
    
    if (moved) {
      isMoving = true;
      animateMovement(originalBoard, board);
    }
  });

  // 触摸事件
  document.addEventListener('touchstart', (e) => {
    if (isGameOver || isMoving) return;
    startX = e.touches[0].clientX;
    startY = e.touches[0].clientY;
  });

  document.addEventListener('touchend', (e) => {
    if (isGameOver || isMoving) return;
    const endX = e.changedTouches[0].clientX;
    const endY = e.changedTouches[0].clientY;

    const diffX = endX - startX;
    const diffY = endY - startY;

    let moved = false;
    const originalBoard = JSON.parse(JSON.stringify(board));

    if (Math.abs(diffX) > Math.abs(diffY)) {
      // 水平滑动
      if (diffX > 50) {
        moved = slideRight();
      } else if (diffX < -50) {
        moved = slideLeft();
      }
    } else {
      // 垂直滑动
      if (diffY > 50) {
        moved = slideDown();
      } else if (diffY < -50) {
        moved = slideUp();
      }
    }

    if (moved) {
      isMoving = true;
      animateMovement(originalBoard, board);
    }
  });

  document.getElementById('restart-btn').addEventListener('click', setupGame);

  // 核心动画函数
  function animateMovement(oldBoard, newBoard) {
    for(let r = 0; r < rows; r++) {
      for(let c = 0; c < cols; c++) {
        const newValue = newBoard[r][c];
        if (newValue !== 0) {
          const oldTileData = findOldTile(newValue.id, oldBoard);
          if (oldTileData) {
            const tileElement = tiles.get(oldTileData.id);
            if (tileElement) {
              const newPos = getPosition(r, c);
              tileElement.style.left = newPos.left;
              tileElement.style.top = newPos.top;
              tileElement.className = `tile tile-${newValue.value}`;
              tileElement.innerText = newValue.value;
            }
          }
        }
      }
    }
    
    const allOldIds = new Set();
    oldBoard.forEach(row => row.forEach(tile => { if (tile !== 0) allOldIds.add(tile.id); }));
    
    const newIds = new Set();
    newBoard.forEach(row => row.forEach(tile => { if (tile !== 0) newIds.add(tile.id); }));

    allOldIds.forEach(oldId => {
      if (!newIds.has(oldId)) {
        const tileElement = tiles.get(oldId);
        if (tileElement) {
          tileElement.style.opacity = '0';
          tileElement.style.transform = 'scale(0.5)';
        }
      }
    });

    setTimeout(() => {
      container.querySelectorAll('.tile').forEach(tile => tile.remove());
      tiles.clear();
      
      for(let r = 0; r < rows; r++) {
        for(let c = 0; c < cols; c++) {
          const tileData = newBoard[r][c];
          if (tileData !== 0) {
            const tileElement = createTileElement(tileData.value, r, c, tileData.id);
            tiles.set(tileData.id, tileElement);
            container.appendChild(tileElement);
          }
        }
      }
      
      document.getElementById('score').innerText = score;
      addRandomTile();
      isMoving = false;
      checkGameOver();
    }, 150);
  }

  function findOldTile(newId, oldBoard) {
    for(let r = 0; r < rows; r++) {
      for(let c = 0; c < cols; c++) {
        if (oldBoard[r][c] !== 0 && oldBoard[r][c].id === newId) {
          return oldBoard[r][c];
        }
      }
    }
    return null;
  }

  function checkGameOver() {
    let canMove = false;
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        if (board[r][c] === 0) return;
        if ((c < cols - 1 && board[r][c].value === board[r][c+1].value) ||
            (r < rows - 1 && board[r][c].value === board[r+1][c].value)) {
          canMove = true;
          break;
        }
      }
      if (canMove) break;
    }

    if (!canMove) {
      isGameOver = true;
      document.getElementById('game-over').style.display = 'flex';
      document.getElementById('final-score').innerText = score;
    }
  }

  function slide(row) {
    let newRow = row.filter(tile => tile !== 0);
    for (let i = 0; i < newRow.length - 1; i++) {
      if (newRow[i].value === newRow[i+1].value) {
        newRow[i].value *= 2;
        score += newRow[i].value;
        newRow.splice(i+1, 1);
        newRow.push(0);
      }
    }
    while (newRow.length < cols) {
      newRow.push(0);
    }
    return newRow;
  }

  function slideLeft() {
    let moved = false;
    for (let r = 0; r < rows; r++) {
      const originalRow = JSON.parse(JSON.stringify(board[r]));
      let newRow = slide(board[r]);
      if (JSON.stringify(originalRow) !== JSON.stringify(newRow)) {
        board[r] = newRow;
        moved = true;
      }
    }
    return moved;
  }

  function slideRight() {
    let moved = false;
    for (let r = 0; r < rows; r++) {
      let row = board[r].filter(tile => tile !== 0);
      row.reverse();
      let newRow = slide(row);
      newRow.reverse();
      while (newRow.length < cols) {
        newRow.unshift(0);
      }
      if (JSON.stringify(board[r]) !== JSON.stringify(newRow)) {
        board[r] = newRow;
        moved = true;
      }
    }
    return moved;
  }
  
  function slideUp() {
    let moved = false;
    for (let c = 0; c < cols; c++) {
      let col = [];
      for (let r = 0; r < rows; r++) {
        col.push(board[r][c]);
      }
      const originalCol = JSON.parse(JSON.stringify(col));
      let newCol = slide(col);
      if (JSON.stringify(originalCol) !== JSON.stringify(newCol)) {
        for (let r = 0; r < rows; r++) {
          board[r][c] = newCol[r];
        }
        moved = true;
      }
    }
    return moved;
  }

  function slideDown() {
    let moved = false;
    for (let c = 0; c < cols; c++) {
      let col = [];
      for (let r = 0; r < rows; r++) {
        col.push(board[r][c]);
      }
      col.reverse();
      let newCol = slide(col);
      newCol.reverse();
      
      let newBoardCol = col.map((_, i) => board[i][c]);
      if (JSON.stringify(newBoardCol) !== JSON.stringify(newCol)) {
        for (let r = 0; r < rows; r++) {
          board[r][c] = newCol[r];
        }
        moved = true;
      }
    }
    return moved;
  }
</script>

</body>
</html>
